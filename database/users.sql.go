// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: users.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/1f349/tulip/database/types"
	"github.com/1f349/tulip/password"
)

const deleteOtp = `-- name: DeleteOtp :exec
DELETE
FROM otp
WHERE otp.subject = ?
`

func (q *Queries) DeleteOtp(ctx context.Context, subject string) error {
	_, err := q.db.ExecContext(ctx, deleteOtp, subject)
	return err
}

const getOtp = `-- name: GetOtp :one
SELECT secret, digits
FROM otp
WHERE subject = ?
`

type GetOtpRow struct {
	Secret string `json:"secret"`
	Digits int64  `json:"digits"`
}

func (q *Queries) GetOtp(ctx context.Context, subject string) (GetOtpRow, error) {
	row := q.db.QueryRowContext(ctx, getOtp, subject)
	var i GetOtpRow
	err := row.Scan(&i.Secret, &i.Digits)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT subject, name, username, password, picture, website, email, email_verified, pronouns, birthdate, zoneinfo, locale, role, updated_at, registered, active
FROM users
WHERE subject = ?
LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, subject string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, subject)
	var i User
	err := row.Scan(
		&i.Subject,
		&i.Name,
		&i.Username,
		&i.Password,
		&i.Picture,
		&i.Website,
		&i.Email,
		&i.EmailVerified,
		&i.Pronouns,
		&i.Birthdate,
		&i.Zoneinfo,
		&i.Locale,
		&i.Role,
		&i.UpdatedAt,
		&i.Registered,
		&i.Active,
	)
	return i, err
}

const getUserDisplayName = `-- name: GetUserDisplayName :one
SELECT name
FROM users
WHERE subject = ?
`

func (q *Queries) GetUserDisplayName(ctx context.Context, subject string) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserDisplayName, subject)
	var name string
	err := row.Scan(&name)
	return name, err
}

const getUserEmail = `-- name: GetUserEmail :one
SELECT email
FROM users
WHERE subject = ?
`

func (q *Queries) GetUserEmail(ctx context.Context, subject string) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserEmail, subject)
	var email string
	err := row.Scan(&email)
	return email, err
}

const getUserRole = `-- name: GetUserRole :one
SELECT role
FROM users
WHERE subject = ?
`

func (q *Queries) GetUserRole(ctx context.Context, subject string) (types.UserRole, error) {
	row := q.db.QueryRowContext(ctx, getUserRole, subject)
	var role types.UserRole
	err := row.Scan(&role)
	return role, err
}

const hasOtp = `-- name: HasOtp :one
SELECT CAST(EXISTS(SELECT 1 FROM otp WHERE subject = ?) AS BOOLEAN)
`

func (q *Queries) HasOtp(ctx context.Context, subject string) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasOtp, subject)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const hasUser = `-- name: HasUser :one
SELECT CAST(count(subject) AS BOOLEAN) AS hasUser
FROM users
`

func (q *Queries) HasUser(ctx context.Context) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasUser)
	var hasuser bool
	err := row.Scan(&hasuser)
	return hasuser, err
}

const modifyUser = `-- name: ModifyUser :exec
UPDATE users
SET name      = ?,
    picture   = ?,
    website=?,
    pronouns=?,
    birthdate=?,
    zoneinfo=?,
    locale=?,
    updated_at=?
WHERE subject = ?
`

type ModifyUserParams struct {
	Name      string            `json:"name"`
	Picture   string            `json:"picture"`
	Website   string            `json:"website"`
	Pronouns  types.UserPronoun `json:"pronouns"`
	Birthdate sql.NullTime      `json:"birthdate"`
	Zoneinfo  types.UserZone    `json:"zoneinfo"`
	Locale    types.UserLocale  `json:"locale"`
	UpdatedAt time.Time         `json:"updated_at"`
	Subject   string            `json:"subject"`
}

func (q *Queries) ModifyUser(ctx context.Context, arg ModifyUserParams) error {
	_, err := q.db.ExecContext(ctx, modifyUser,
		arg.Name,
		arg.Picture,
		arg.Website,
		arg.Pronouns,
		arg.Birthdate,
		arg.Zoneinfo,
		arg.Locale,
		arg.UpdatedAt,
		arg.Subject,
	)
	return err
}

const setOtp = `-- name: SetOtp :exec
INSERT OR
REPLACE
INTO otp (subject, secret, digits)
VALUES (?, ?, ?)
`

type SetOtpParams struct {
	Subject string `json:"subject"`
	Secret  string `json:"secret"`
	Digits  int64  `json:"digits"`
}

func (q *Queries) SetOtp(ctx context.Context, arg SetOtpParams) error {
	_, err := q.db.ExecContext(ctx, setOtp, arg.Subject, arg.Secret, arg.Digits)
	return err
}

const addUser = `-- name: addUser :exec
INSERT INTO users (subject, name, username, password, email, email_verified, role, updated_at, active)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type addUserParams struct {
	Subject       string              `json:"subject"`
	Name          string              `json:"name"`
	Username      string              `json:"username"`
	Password      password.HashString `json:"password"`
	Email         string              `json:"email"`
	EmailVerified bool                `json:"email_verified"`
	Role          types.UserRole      `json:"role"`
	UpdatedAt     time.Time           `json:"updated_at"`
	Active        bool                `json:"active"`
}

func (q *Queries) addUser(ctx context.Context, arg addUserParams) error {
	_, err := q.db.ExecContext(ctx, addUser,
		arg.Subject,
		arg.Name,
		arg.Username,
		arg.Password,
		arg.Email,
		arg.EmailVerified,
		arg.Role,
		arg.UpdatedAt,
		arg.Active,
	)
	return err
}

const changeUserPassword = `-- name: changeUserPassword :exec
UPDATE users
SET password   = ?,
    updated_at = ?
WHERE subject = ?
  AND password = ?
`

type changeUserPasswordParams struct {
	Password   password.HashString `json:"password"`
	UpdatedAt  time.Time           `json:"updated_at"`
	Subject    string              `json:"subject"`
	Password_2 password.HashString `json:"password_2"`
}

func (q *Queries) changeUserPassword(ctx context.Context, arg changeUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, changeUserPassword,
		arg.Password,
		arg.UpdatedAt,
		arg.Subject,
		arg.Password_2,
	)
	return err
}

const checkLogin = `-- name: checkLogin :one
SELECT subject, name, password, CAST(EXISTS(SELECT 1 FROM otp WHERE otp.subject = users.subject) AS BOOLEAN) AS has_otp, email, email_verified
FROM users
WHERE username = ?
LIMIT 1
`

type checkLoginRow struct {
	Subject       string              `json:"subject"`
	Name          string              `json:"name"`
	Password      password.HashString `json:"password"`
	HasOtp        bool                `json:"has_otp"`
	Email         string              `json:"email"`
	EmailVerified bool                `json:"email_verified"`
}

func (q *Queries) checkLogin(ctx context.Context, username string) (checkLoginRow, error) {
	row := q.db.QueryRowContext(ctx, checkLogin, username)
	var i checkLoginRow
	err := row.Scan(
		&i.Subject,
		&i.Name,
		&i.Password,
		&i.HasOtp,
		&i.Email,
		&i.EmailVerified,
	)
	return i, err
}

const getUserPassword = `-- name: getUserPassword :one
SELECT password
FROM users
WHERE subject = ?
`

func (q *Queries) getUserPassword(ctx context.Context, subject string) (password.HashString, error) {
	row := q.db.QueryRowContext(ctx, getUserPassword, subject)
	var password password.HashString
	err := row.Scan(&password)
	return password, err
}
