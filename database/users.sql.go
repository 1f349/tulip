// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: users.sql

package database

import (
	"context"
	"database/sql"
)

const deleteTwoFactor = `-- name: DeleteTwoFactor :exec
DELETE
FROM otp
WHERE otp.subject = ?
`

func (q *Queries) DeleteTwoFactor(ctx context.Context, subject string) error {
	_, err := q.db.ExecContext(ctx, deleteTwoFactor, subject)
	return err
}

const getTwoFactor = `-- name: GetTwoFactor :one
SELECT secret, digits
FROM otp
WHERE subject = ?
`

type GetTwoFactorRow struct {
	Secret string `json:"secret"`
	Digits int64  `json:"digits"`
}

func (q *Queries) GetTwoFactor(ctx context.Context, subject string) (GetTwoFactorRow, error) {
	row := q.db.QueryRowContext(ctx, getTwoFactor, subject)
	var i GetTwoFactorRow
	err := row.Scan(&i.Secret, &i.Digits)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT name,
       username,
       picture,
       website,
       email,
       email_verified,
       pronouns,
       birthdate,
       zoneinfo,
       locale,
       updated_at,
       active
FROM users
WHERE subject = ?
LIMIT 1
`

type GetUserRow struct {
	Name          string        `json:"name"`
	Username      string        `json:"username"`
	Picture       interface{}   `json:"picture"`
	Website       interface{}   `json:"website"`
	Email         string        `json:"email"`
	EmailVerified int64         `json:"email_verified"`
	Pronouns      interface{}   `json:"pronouns"`
	Birthdate     sql.NullTime  `json:"birthdate"`
	Zoneinfo      interface{}   `json:"zoneinfo"`
	Locale        interface{}   `json:"locale"`
	UpdatedAt     sql.NullTime  `json:"updated_at"`
	Active        sql.NullInt64 `json:"active"`
}

func (q *Queries) GetUser(ctx context.Context, subject string) (GetUserRow, error) {
	row := q.db.QueryRowContext(ctx, getUser, subject)
	var i GetUserRow
	err := row.Scan(
		&i.Name,
		&i.Username,
		&i.Picture,
		&i.Website,
		&i.Email,
		&i.EmailVerified,
		&i.Pronouns,
		&i.Birthdate,
		&i.Zoneinfo,
		&i.Locale,
		&i.UpdatedAt,
		&i.Active,
	)
	return i, err
}

const hasUser = `-- name: HasUser :one
SELECT cast(count(subject) AS BOOLEAN) AS hasUser
FROM users
`

func (q *Queries) HasUser(ctx context.Context) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasUser)
	var hasuser bool
	err := row.Scan(&hasuser)
	return hasuser, err
}

const modifyUser = `-- name: ModifyUser :execrows
UPDATE users
SET name      = ?,
    picture   = ?,
    website=?,
    pronouns=?,
    birthdate=?,
    zoneinfo=?,
    locale=?,
    updated_at=?
WHERE subject = ?
`

type ModifyUserParams struct {
	Name      string       `json:"name"`
	Picture   interface{}  `json:"picture"`
	Website   interface{}  `json:"website"`
	Pronouns  interface{}  `json:"pronouns"`
	Birthdate sql.NullTime `json:"birthdate"`
	Zoneinfo  interface{}  `json:"zoneinfo"`
	Locale    interface{}  `json:"locale"`
	UpdatedAt sql.NullTime `json:"updated_at"`
	Subject   string       `json:"subject"`
}

func (q *Queries) ModifyUser(ctx context.Context, arg ModifyUserParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, modifyUser,
		arg.Name,
		arg.Picture,
		arg.Website,
		arg.Pronouns,
		arg.Birthdate,
		arg.Zoneinfo,
		arg.Locale,
		arg.UpdatedAt,
		arg.Subject,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const setTwoFactor = `-- name: SetTwoFactor :exec
INSERT OR
REPLACE
INTO otp (subject, secret, digits)
VALUES (?, ?, ?)
`

type SetTwoFactorParams struct {
	Subject string `json:"subject"`
	Secret  string `json:"secret"`
	Digits  int64  `json:"digits"`
}

func (q *Queries) SetTwoFactor(ctx context.Context, arg SetTwoFactorParams) error {
	_, err := q.db.ExecContext(ctx, setTwoFactor, arg.Subject, arg.Secret, arg.Digits)
	return err
}

const addUser = `-- name: addUser :exec
INSERT INTO users (subject, name, username, password, email, email_verified, role, updated_at, active)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type addUserParams struct {
	Subject       string        `json:"subject"`
	Name          string        `json:"name"`
	Username      string        `json:"username"`
	Password      string        `json:"password"`
	Email         string        `json:"email"`
	EmailVerified int64         `json:"email_verified"`
	Role          int64         `json:"role"`
	UpdatedAt     sql.NullTime  `json:"updated_at"`
	Active        sql.NullInt64 `json:"active"`
}

func (q *Queries) addUser(ctx context.Context, arg addUserParams) error {
	_, err := q.db.ExecContext(ctx, addUser,
		arg.Subject,
		arg.Name,
		arg.Username,
		arg.Password,
		arg.Email,
		arg.EmailVerified,
		arg.Role,
		arg.UpdatedAt,
		arg.Active,
	)
	return err
}

const changeUserPassword = `-- name: changeUserPassword :execrows
UPDATE users
SET password   = ?,
    updated_at = ?
WHERE subject = ?
  AND password = ?
`

type changeUserPasswordParams struct {
	Password   string       `json:"password"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	Subject    string       `json:"subject"`
	Password_2 string       `json:"password_2"`
}

func (q *Queries) changeUserPassword(ctx context.Context, arg changeUserPasswordParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, changeUserPassword,
		arg.Password,
		arg.UpdatedAt,
		arg.Subject,
		arg.Password_2,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const checkLogin = `-- name: checkLogin :one
SELECT subject, password, EXISTS(SELECT 1 FROM otp WHERE otp.subject = users.subject), email, email_verified
FROM users
WHERE username = ?
LIMIT 1
`

type checkLoginRow struct {
	Subject       string `json:"subject"`
	Password      string `json:"password"`
	Column3       int64  `json:"column_3"`
	Email         string `json:"email"`
	EmailVerified int64  `json:"email_verified"`
}

func (q *Queries) checkLogin(ctx context.Context, username string) (checkLoginRow, error) {
	row := q.db.QueryRowContext(ctx, checkLogin, username)
	var i checkLoginRow
	err := row.Scan(
		&i.Subject,
		&i.Password,
		&i.Column3,
		&i.Email,
		&i.EmailVerified,
	)
	return i, err
}

const getUserPassword = `-- name: getUserPassword :one
SELECT password
FROM users
WHERE subject = ?
`

func (q *Queries) getUserPassword(ctx context.Context, subject string) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserPassword, subject)
	var password string
	err := row.Scan(&password)
	return password, err
}
